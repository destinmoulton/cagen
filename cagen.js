// Generated by CoffeeScript 1.8.0

/*
board.coffee

@author Destin Moulton

Generate an NKS cellular automata board based on a passed rule.
 */

(function() {
  var Board, Console, RootRowEditor, RuleMatcher,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Board = (function() {
    function Board() {
      this._boardContainerID = '#nks-board-container';
      this._boardNoCellsWide = 0;
      this._boardNoCellsHigh = 0;
      this._boardCellWidthPx = 5;
      this._boardCellHeightPx = 5;
      this._cellBaseClass = 'nks-cell';
      this._cellActiveClass = 'nks-cell-active';
      this._cellIDPrefix = 'sb_';
      this._currentRow = 1;
      this._jBoard = $(this._boardContainerID);
      this._currentCells = [];
      this._RuleMatcher = new RuleMatcher();
    }

    Board.prototype.build_board = function(decimal_rule, sections_wide, sections_high) {
      var row, _i, _ref, _results;
      this._RuleMatcher.setCurrentRule(decimal_rule);
      this._boardNoCellsWide = sections_wide;
      this._boardNoCellsHigh = sections_high;
      this._jBoard.width(sections_wide * this._boardCellWidthPx);
      this._jBoard.height(sections_high * this._boardCellHeightPx);
      this._jBoard.html("");
      this._currentRow = 1;
      this._buildTopRow();
      _results = [];
      for (row = _i = 2, _ref = this._boardNoCellsHigh; 2 <= _ref ? _i <= _ref : _i >= _ref; row = 2 <= _ref ? ++_i : --_i) {
        this._currentRow = row;
        _results.push(this._buildRow(row));
      }
      return _results;
    };

    Board.prototype.getCurrentRule = function() {
      return this._RuleMatcher.getCurrentRule();
    };

    Board.prototype._buildRow = function(row) {
      var col, oneIndex, twoIndex, zeroIndex, _i, _ref;
      for (col = _i = 1, _ref = this._boardNoCellsWide; 1 <= _ref ? _i <= _ref : _i >= _ref; col = 1 <= _ref ? ++_i : --_i) {
        zeroIndex = this._currentCells[row - 1][col - 1];
        if (zeroIndex === void 0) {
          zeroIndex = this._currentCells[row - 1][this._boardNoCellsWide];
        }
        oneIndex = this._currentCells[row - 1][col];
        twoIndex = this._currentCells[row - 1][col + 1];
        if (twoIndex === void 0) {
          twoIndex = this._currentCells[row - 1][1];
        }
        if (this._RuleMatcher.match(zeroIndex, oneIndex, twoIndex) === 0) {
          this._addBlockToBoard(row, col, false);
        } else {
          this._addBlockToBoard(row, col, true);
        }
      }
      return this._currentRow++;
    };

    Board.prototype._buildTopRow = function() {
      var col, seed_col, _i, _ref;
      seed_col = Math.ceil(this._boardNoCellsWide / 2);
      for (col = _i = 1, _ref = this._boardNoCellsWide; 1 <= _ref ? _i <= _ref : _i >= _ref; col = 1 <= _ref ? ++_i : --_i) {
        if (col === seed_col) {
          this._addBlockToBoard(this._currentRow, col, true);
        } else {
          this._addBlockToBoard(this._currentRow, col, false);
        }
      }
      return this._currentRow++;
    };

    Board.prototype._addBlockToBoard = function(row, col, active) {
      var tmpClass, tmpDiv, tmpID, tmpLeftPx, tmpStyle, tmpTopPx;
      if (!this._currentCells[row]) {
        this._currentCells[row] = [];
      }
      this._currentCells[row][col] = active ? 1 : 0;
      tmpID = this._cellIDPrefix + this._currentRow + "_" + col;
      tmpLeftPx = (col - 1) * this._boardCellWidthPx;
      tmpTopPx = (row - 1) * this._boardCellHeightPx;
      tmpStyle = " style='top:" + tmpTopPx + "px;left:" + tmpLeftPx + "px;' ";
      tmpClass = this._cellBaseClass;
      if (active) {
        tmpClass = " " + tmpClass + " " + this._cellActiveClass + " ";
      }
      tmpDiv = "<div id='" + tmpID + "' class='" + tmpClass + "' " + tmpStyle + "></div>";
      return this._jBoard.append(tmpDiv);
    };

    return Board;

  })();


  /*
  console.coffee
  
  @author Destin Moulton
  
  Funcionality for building the console for
  controlling the cellular automata generation.
  
  Display a preview of the rules.
   */

  Console = (function() {
    function Console() {
      this._jInputSelectRule = $("#nks-console-select");
      this._jButtonGenerate = $("#nks-console-button");
      this._jInputColumns = $("#nks-width-input");
      this._jInputRows = $("#nks-height-input");
      this._jRulesContainer = $('#nks-rules-preview-container');
      this._previewCellPrefixID = "#nks-console-preview-";
      this._previewDigitPrefixID = "#nks-console-preview-digit-";
      this._Board = new Board();
    }

    Console.prototype.run = function() {
      var rule, tmpOption, _i;
      for (rule = _i = 0; _i <= 255; rule = ++_i) {
        tmpOption = "<option value='" + rule + "'>" + rule + "</option>";
        this._jInputSelectRule.append(tmpOption);
      }
      return this._jButtonGenerate.click((function(_this) {
        return function() {
          return _this._generateButtonClicked(event);
        };
      })(this));
    };

    Console.prototype._generateButtonClicked = function(event) {
      this._jRulesContainer.fadeOut();
      this._Board.build_board(this._jInputSelectRule.val(), this._jInputColumns.val(), this._jInputRows.val());
      this._buildRulePreview();
      return false;
    };

    Console.prototype._buildRulePreview = function() {
      var activeClass, currentRule, index, jTmpCell, jTmpDigit, _i;
      currentRule = this._Board.getCurrentRule();
      activeClass = 'nks-console-preview-cell-active';
      for (index = _i = 0; _i <= 7; index = ++_i) {
        jTmpCell = $(this._previewCellPrefixID + index);
        jTmpDigit = $(this._previewDigitPrefixID + index);
        jTmpCell.removeClass(activeClass);
        jTmpDigit.html(0);
        if (currentRule.substr(index, 1) === "1") {
          jTmpCell.addClass(activeClass);
          jTmpDigit.html(1);
        }
      }
      return this._jRulesContainer.fadeIn();
    };

    return Console;

  })();

  $(function() {
    var rowEditor;
    rowEditor = new RootRowEditor();
    return rowEditor.run();
  });

  RootRowEditor = (function() {
    function RootRowEditor() {
      this._toggleEditorCell = __bind(this._toggleEditorCell, this);
      this._moveSlider = __bind(this._moveSlider, this);
      var editorContainerId, rowContainerId, sliderContainerId, sliderId;
      rowContainerId = "#rowed-slider-row-container";
      sliderContainerId = "#rowed-slider-container";
      sliderId = "#rowed-slider";
      editorContainerId = "#rowed-editor-container";
      this._editorCellActiveClass = 'rowed-editor-cell-active';
      this._sliderCellActiveClass = 'nks-cell-active';
      this._jSliderContainer = $(sliderContainerId);
      this._jSlider = $(sliderId);
      this._jRowContainer = $(rowContainerId);
      this._jEditorContainer = $(editorContainerId);
      this._jEditorCells = [];
      this._aRowBinary = [];
      this._noColumns = 151;
      this._colWidth = 5;
      this._rowHeight = 5;
      this._sliderLeft = 0;
      this._sliderCols = 26;
      this._sliderPxToMid = (this._sliderCols / 2) * this._colWidth;
      this._editorCellWidth = 29;
      this._generateInitialBinary();
    }

    RootRowEditor.prototype.run = function() {
      this._totalWidth = this._colWidth * this._noColumns;
      this._jRowContainer.height(this._rowHeight);
      this._jRowContainer.width(this._totalWidth);
      this._jSliderContainer.width(this._totalWidth);
      this._jSlider.width(this._colWidth * this._sliderCols);
      this._jSliderContainer.mousemove(this._moveSlider);
      this._sliderInitialOffset = this._jSlider.offset();
      this._buildRow();
      this._buildEditorCells();
      return this._updateEditorCells(1);
    };

    RootRowEditor.prototype._moveSlider = function(ev) {
      var closestEdgePx, leftCellNo, leftPos, rightPos, xMousePos;
      xMousePos = ev.clientX;
      closestEdgePx = xMousePos - (xMousePos % this._colWidth);
      leftPos = closestEdgePx - this._sliderPxToMid;
      rightPos = closestEdgePx + this._sliderPxToMid + this._colWidth;
      if (leftPos >= this._sliderInitialOffset.left && rightPos <= (this._totalWidth + this._sliderInitialOffset.left)) {
        this._jSlider.offset({
          top: this._sliderInitialOffset.top,
          left: leftPos
        });
        leftCellNo = (leftPos / this._colWidth) - 1;
        return this._updateEditorCells(leftCellNo);
      }
    };

    RootRowEditor.prototype._updateEditorCells = function(beginCell) {
      var cell, cellPos, _i, _ref, _results;
      _results = [];
      for (cell = _i = 1, _ref = this._sliderCols; 1 <= _ref ? _i <= _ref : _i >= _ref; cell = 1 <= _ref ? ++_i : --_i) {
        cellPos = cell + beginCell - 1;
        this._jEditorCells[cell].text(cellPos);
        this._jEditorCells[cell].data('cellIndex', cellPos);
        if (this._aRowBinary[cellPos] === 1) {
          _results.push(this._jEditorCells[cell].addClass(this._editorCellActiveClass));
        } else {
          _results.push(this._jEditorCells[cell].removeClass(this._editorCellActiveClass));
        }
      }
      return _results;
    };

    RootRowEditor.prototype._buildEditorCells = function() {
      var cell, cellTemplate, leftPos, rendered, tmpId, _i, _ref, _results;
      cellTemplate = $('#tmpl-rowed-editor-cell').html();
      Mustache.parse(cellTemplate);
      this._jEditorContainer.width(this._sliderCols * this._editorCellWidth);
      _results = [];
      for (cell = _i = 1, _ref = this._sliderCols; 1 <= _ref ? _i <= _ref : _i >= _ref; cell = 1 <= _ref ? ++_i : --_i) {
        tmpId = "editor-cell-" + cell;
        leftPos = (cell - 1) * this._editorCellWidth;
        rendered = Mustache.render(cellTemplate, {
          id: tmpId,
          left: leftPos
        });
        this._jEditorContainer.append(rendered);
        this._jEditorCells[cell] = $("#" + tmpId);
        _results.push(this._jEditorCells[cell].click(this._toggleEditorCell));
      }
      return _results;
    };

    RootRowEditor.prototype._toggleEditorCell = function(event) {
      var cellNo, jTmpCell;
      jTmpCell = $("#" + event.target.id);
      cellNo = jTmpCell.data('cellIndex');
      if (this._aRowBinary[cellNo] === 1) {
        this._aRowBinary[cellNo] = 0;
        jTmpCell.removeClass(this._editorCellActiveClass);
        return $('#rowed-slider-col-' + cellNo).removeClass(this._sliderCellActiveClass);
      } else {
        this._aRowBinary[cellNo] = 1;
        jTmpCell.addClass(this._editorCellActiveClass);
        return $('#rowed-slider-col-' + cellNo).addClass(this._sliderCellActiveClass);
      }
    };

    RootRowEditor.prototype._generateInitialBinary = function() {
      var col, seed_col, _i, _ref, _results;
      seed_col = Math.ceil(this._noColumns / 2);
      _results = [];
      for (col = _i = 1, _ref = this._noColumns; 1 <= _ref ? _i <= _ref : _i >= _ref; col = 1 <= _ref ? ++_i : --_i) {
        if (col === seed_col) {
          _results.push(this._aRowBinary[col] = 1);
        } else {
          _results.push(this._aRowBinary[col] = 0);
        }
      }
      return _results;
    };

    RootRowEditor.prototype._buildRow = function() {
      var activeClass, col, leftPos, rendered, smallCellTemplate, tmpId, _i, _ref, _results;
      smallCellTemplate = $('#tmpl-rowed-slider-cell').html();
      Mustache.parse(smallCellTemplate);
      _results = [];
      for (col = _i = 1, _ref = this._noColumns; 1 <= _ref ? _i <= _ref : _i >= _ref; col = 1 <= _ref ? ++_i : --_i) {
        activeClass = "";
        if (this._aRowBinary[col] === 1) {
          activeClass = this._sliderCellActiveClass;
        }
        leftPos = (col - 1) * this._colWidth;
        tmpId = "rowed-slider-col-" + col;
        rendered = Mustache.render(smallCellTemplate, {
          id: tmpId,
          left: leftPos,
          activeClass: activeClass
        });
        _results.push(this._jRowContainer.append(rendered));
      }
      return _results;
    };

    return RootRowEditor;

  })();


  /*
  rulematcher.coffee
  
  @author Destin Moulton
  
  The rule is a binary string. Each 1 in the binary string
  represents a rule to-be-followed in the next row of
  generated blocks.
  
  There are 255 rules of 8 block positions.
  
  Rule 255 is as follows:
  111 110 101 100 011 010 001 000
   1   1   1   1   1   1   1   1
  
  The first row has one block in the center as a seed.
   */

  RuleMatcher = (function() {
    function RuleMatcher() {
      this._binaryRule = "";
      this._patterns = ['111', '110', '101', '100', '011', '010', '001', '000'];
    }

    RuleMatcher.prototype.setCurrentRule = function(decimalRule) {
      return this._binaryRule = this._decToBinary(decimalRule);
    };

    RuleMatcher.prototype.getCurrentRule = function() {
      return this._binaryRule;
    };

    RuleMatcher.prototype.match = function(zeroIndex, oneIndex, twoIndex) {
      var foundPatternIndex, patternToFind;
      patternToFind = "" + zeroIndex + oneIndex + twoIndex;
      foundPatternIndex = this._patterns.indexOf(patternToFind);
      return parseInt(this._binaryRule.substr(foundPatternIndex, 1));
    };

    RuleMatcher.prototype._decToBinary = function(decValue) {
      var binary, length, num, _i;
      binary = (parseInt(decValue)).toString(2);
      length = binary.length;
      if (length < 8) {
        for (num = _i = length; length <= 7 ? _i <= 7 : _i >= 7; num = length <= 7 ? ++_i : --_i) {
          binary = "0" + binary;
        }
      }
      return binary;
    };

    return RuleMatcher;

  })();

}).call(this);
